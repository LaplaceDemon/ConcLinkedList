/*
 *  linkedlist.c
 *
 *  Description:
 *   Lock-free linkedlist implementation of Harris' algorithm
 *   "A Pragmatic Implementation of Non-Blocking Linked Lists" 
 *   T. Harris, p. 300-314, DISC 2001.
 */

#include "linkedlist.h"

/*
 * The five following functions handle the low-order mark bit that indicates
 * whether a node is logically deleted (1) or not (0).
 *  - is_marked_ref returns whether it is marked, 
 *  - (un)set_marked changes the mark,
 *  - get_(un)marked_ref sets the mark before returning the node.
 */
inline int
is_marked_ref(long i) 
{
  return (int) (i & 0x1L);
}

inline long
unset_mark(long i)
{
  i &= ~0x1L;
  return i;
}

inline long
set_mark(long i) 
{
  i |= 0x1L;
  return i;
}

inline long
get_unmarked_ref(long w) 
{
  return w & ~0x1L;
}

inline long
get_marked_ref(long w) 
{
  return w | 0x1L;
}

/*
 * list_search looks for value val, it
 *  - returns right_node owning val (if present) or its immediately higher 
 *    value present in the list (otherwise) and 
 *  - sets the left_node to the node owning the value immediately lower than val. 
 * Encountered nodes that are marked as logically deleted are physically removed
 * from the list, yet not garbage collected.
 */
node_t* list_search(llist_t* set, val_t val, node_t** left_node) 
{
  node_t *left_node_next, *right_node;
  search_again:
  do {
    node_t *t = set->head;
    node_t *t_next = set->head->next;
    /* 1: Find left_node and right_node */
    do {
      if (is_marked_ref((long)t_next) == 0) {
        (*left_node) = t;
        left_node_next = t_next;
      }
      t = (node_t*) get_unmarked_ref((long)t_next);
      if (t == set->tail) break;
      t_next = t->next;
    } while (is_marked_ref((long)t_next) != 0 || (t->data < val)); /*B1*/
    right_node = t;
    /* 2: Check nodes are adjacent */
    if (left_node_next == right_node){
      if ((right_node != set->tail) && is_marked_ref((long)right_node->next) != 0)
        goto search_again; /*G1*/
      else return right_node; /*R1*/
    }
    /* 3: Remove one or more marked nodes */
    if (CAS_PTR(&((*left_node)->next), left_node_next, right_node) == left_node_next) /*C1*/{
      if ((right_node != set->tail) && is_marked_ref((long)right_node->next) != 0)
        goto search_again; /*G2*/
      else
        return right_node; /*R2*/
    }
  } while (1); /*B2*/
}

/*
 * list_contains returns a value different from 0 whether there is a node in the list owning value val.
 */

int list_contains(llist_t* the_list, val_t val)
{
  //printf("Contains method\n");
  node_t *right_node, *left_node;
  right_node = list_search(the_list, val, &left_node);
  if ((right_node == the_list->tail) ||
  (right_node->data != val))
  return 0;
  else
  return 1;
}


node_t* new_node(val_t val, node_t *next)
{
  //printf("New node method\n");
  // allocate node
  node_t* node = malloc(sizeof(node_t));
  node->data = val;
  node->next = next;
  return node;
}

llist_t* list_new()
{
  //printf("Create list method\n");
  // allocate list
  llist_t* the_list = malloc(sizeof(llist_t));

  // now need to create the sentinel node
  the_list->head = new_node(INT_MIN, NULL);
  the_list->tail = new_node(INT_MAX, NULL);
  the_list->head->next = the_list->tail;
  return the_list;
}

void list_delete(llist_t *the_list)
{
}

int list_size(llist_t* the_list) 
{ 
  int size = 0; 
  node_t* t=the_list->head; 
  while(t!=the_list->tail){ 
    if (is_marked_ref((long)t->next) != 0){ 
      t = (node_t*) get_unmarked_ref((long) t->next); 
    }
    else { 
      size=size+1; 
      t = t->next; 
    } 
  } 


  
  return size-1; 
} 

/*
 * list_add inserts a new node with the given value val in the list
 * (if the value was absent) or does nothing (if the value is already present).
 */

int list_add(llist_t *the_list, val_t val)
{
  node_t *newElem = new_node(val, NULL);
  node_t *right_node, *left_node;
  do {
    right_node = list_search(the_list, val, &left_node);
    if ((right_node != the_list->tail) && (right_node->data == val)) /*T1*/
    return 0;
    newElem->next = right_node;
    if (CAS_PTR(&(left_node->next), right_node, newElem) == right_node) /*C2*/
      return 1;
  } while (1); /*B3*/
}

/*
 * list_remove deletes a node with the given value val (if the value is present) 
 * or does nothing (if the value is already present).
 * The deletion is logical and consists of setting the node mark bit to 1.
 */
int list_remove(llist_t *the_list, val_t val)
{
  node_t* right, left;
  while(1){
    right = list_search(the_list, val, &left);
    if (right == the_list->tail || right->value != val){
      return 0;
    }
    node_t *right_next = right->next;
    if (!is_marked_ref(right->next)){
      if (CAS_PTR(&(right->next), right_next, get_marked_ref(right_next)) == right_next){
        return 1;
      }
    }
  }
}

